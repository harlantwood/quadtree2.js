/*
 * - quadtree2 0.0.1
 * - Two dimensional quadtree for regions and collision detection.
 * - by Burning Gramma <burninggramma@gmail.com>
 * - https://github.com/burninggramma/quadtree2.js
 * --------------------------------------------
 * built on 2014-01-26
*/
var injector=function(a,b){return"undefined"!=typeof module&&"object"==typeof module.exports?b():a()},Vec2=injector(function(){if(!window.Vec2)throw new Error("Vec2 is a requirement");return window.Vec2},function(){return require("vec2")}),fnName=function(a){var b=a.toString();return b=b.substr("function ".length),b=b.substr(0,b.indexOf("("))},thrower=function(a,b,c){var d=a;throw c&&(d+="_"+c),b&&(d+=" - "),b&&c&&(d+=c+": "),b&&(d+=b),new Error(d)},Quadtree2,Quadtree2Quadrant,Quadtree2Validator;Quadtree2Quadrant=function(a,b){this.leftTop_=a.clone(),this.children_=[],this.objects_=[],this.setSize(b)},Quadtree2Quadrant.prototype={setSize:function(a){a&&(this.size_=a,this.rad_=a.multiply(.5,!0),this.center_=this.leftTop_.add(this.rad_,!0),this.leftBot_=this.leftTop_.clone(),this.leftBot_.y+=a.y,this.rightTop_=this.leftTop_.clone(),this.rightTop_.x+=a.x,this.rightBot_=this.leftTop_.add(a,!0),this.leftMid_=this.center_.clone(),this.leftMid_.x=this.leftTop_.x,this.topMid_=this.center_.clone(),this.topMid_.y=this.leftTop_.y)},makeChildren:function(){return this.children_.length>0?!1:(this.children_.push(new Quadtree2Quadrant(this.leftTop_,this.rad_),new Quadtree2Quadrant(this.topMid_,this.rad_),new Quadtree2Quadrant(this.leftMid_,this.rad_),new Quadtree2Quadrant(this.center_,this.rad_)),!0)},cleanObjects:function(){this.objects_=this.objects_.filter(function(a){return void 0===a})},addObject:function(a){this.objects_.push(a)},removeObjects:function(){var a=this.objects_;return this.objects_=[],a},intersectingChildren:function(a,b){return this.children_.filter(function(c){return c.intersects(a,b)})},intersects:function(a,b){var c=a.subtract(this.center_,!0).abs();return c.x>this.rad_.x+b?!1:c.y>this.rad_.y+b?!1:c.x<=this.rad_.x?!0:c.y<=this.rad_.y?!0:(cornerDistSq=Math.pow(c.x,2)+Math.pow(c.y,2),cornerDistSq<=Math.pow(b,2))},hasChildren:function(){return 0!==this.getChildCount()},getChildCount:function(a){var b=this.children_.length;return a&&this.children_.forEach(function(c){b+=c.getChildCount(a)}),b},getObjectCount:function(a){var b=this.objects_.length;return a&&this.children_.forEach(function(c){b+=c.getObjectCount(a)}),b},getChildren:function(a,b){return b||(b=[]),b.push.apply(b,this.children_),a&&this.children_.forEach(function(c){c.getChildren(a,b)}),b}},Quadtree2=function(a,b,c){var d,e={root_:new Quadtree2Quadrant(new Vec2(0,0)),objects_:{},ids_:0,autoId_:!0,inited_:!1,limit_:void 0,size_:void 0,shapes_:{}},f=new Quadtree2Validator,g={p:"pos_",r:"rad_",R:"rot_",id:"id_"},h={data:{necessary:{size_:f.isVec2,limit_:f.isNumber}},k:{necessary:{p:f.isVec2},c:{necessary:{r:f.isNumber}},r:{necessary:{R:f.isNumber}}}},i={nextId:function(){return++e.ids_},hasCollision:function(a,b){return("c"!==i.getObjShape(a)||"c"!==i.getObjShape(b))&&thrower("NIY","Collision handling does not work for rects YET!"),a[g.r]+b[g.r]>a[g.p].distance(b[g.p])},getSmallestQuadrants:function(a,b,c,d){var f,h;if(b||(b=e.root_),c||(c=[]),h=b.intersectingChildren(a[g.p],a[g.r]),h.length===b.getChildCount())(d||b.intersects(a[g.p],a[g.r]))&&c.push(b);else for(f in h)i.getSmallestQuadrants(a,h[f],c,!0);return c},addObjToQuadrant:function(a,b){var c,d,f,g;b||(b=e.root_),b.hasChildren()?(f=i.getSmallestQuadrants(a,b),1===f.length&&f[0]===b?b.addObject(a):(c=function(b){i.addObjToQuadrant(a,b)},f.forEach(c))):b.getObjectCount()<e.limit_?b.addObject(a):(b.makeChildren(),g=b.removeObjects(),g.push(a),d=function(a){i.addObjToQuadrant(a,b)},g.forEach(d))},getCollisionsInQuadrant:function(a,b){var c,d,f,g=[];if(a||(a=e.root_),b||(b=[]),b.push.apply(b,a.objects_),0===a.children_.length)for(c=0;c<b.length;c++)for(d=c+1;d<b.length;d++)i.hasCollision(b[c],b[d])&&g.push([b[c],b[d]]);for(c in a.children_)f=b.slice(0),g.concat(i.getCollisionInQuadrant(a.children_[c],f));return g},init:function(){f.byCallbackObject(e,h.data.necessary),e.root_.setSize(e.size_.clone()),e.inited_=!0},checkInit:function(a){return a&&!e.inited_&&i.init(),e.inited_},checkObjectKeys:function(a){f.isDefined(a[g.id],g.id),f.hasNoKey(e.objects_,a[g.id],g.id),f.byCallbackObject(a,h.k.necessary,g),f.byCallbackObject(a,h.k[i.getObjShape(a)].necessary,g)},setObjId:function(a){e.autoId_&&(a[g.id]=i.nextId())},setObjShape:function(a){var b=void 0===a[g.r],c=b?g.R:g.r;f.isDefined(a[c],c),e.shapes_[a[g.id]]=b?"r":"c"},getObjShape:function(a){return e.shapes_[a[g.id]]}},j={getQuadrants:function(){return e.root_.getChildren(!0,[e.root_])},getLeafQuadrants:function(){return j.getQuadrants().filter(function(a){return!a.hasChildren()})}},k={getLimit:function(){return e.limit_},setLimit:function(a){void 0!==a&&(f.isNumber(a,"limit_"),e.limit_=a)},setObjectKey:function(a,b){f.fnFalse(i.checkInit),void 0!==b&&(f.hasKey(g,a,a),f.isString(b,a),"id"===a&&(e.autoId_=!1),g[a]=b)},getSize:function(){return e.size_.clone()},setSize:function(a){void 0!==a&&(f.isVec2(a,"size_"),e.size_=a.clone())},addObjects:function(a){a.forEach(function(a){k.addObject(a)})},addObject:function(a){f.isDefined(a,"obj"),f.isObject(a,"obj"),i.checkInit(!0),i.setObjId(a),i.setObjShape(a),i.checkObjectKeys(a),i.addObjToQuadrant(a),e.objects_[a[g.id]]=a},getCollidedObjects:function(){return i.checkInit(!0),i.getCollisionsInQuadrant()},getCount:function(){return Object.keys(e.objects_).length},getQuadrantCount:function(){return 1+e.root_.getChildCount(!0)},getQuadrantObjectCount:function(){return e.root_.getObjectCount(!0)},debug:function(a){var b;if(void 0!==a){e.debug_=a,i.checkInit(!0);for(b in j)this[b]=j[b];for(b in i)this[b]=i[b]}return e.debug_}};for(d in k)this[d]=k[d];this.setSize(a),this.setLimit(b),this.setObjectKey("id",c)},Quadtree2Validator=function(){},Quadtree2Validator.prototype={isNumber:function(a,b){"number"!=typeof a&&thrower("NaN","Not a Number",b)},isString:function(a,b){"string"==typeof a||a instanceof String||thrower("NaS","Not a String",b)},isVec2:function(a,b){var c=!1;c="object"!=typeof a||!(a instanceof Vec2),c=c||void 0===a.x||void 0===a.y,c&&thrower("NaV","Not a Vec2",b)},isDefined:function(a,b){void 0===a&&thrower("ND","Not defined",b)},isObject:function(a,b){"object"!=typeof a&&thrower("NaO","Not an Object",b)},hasKey:function(a,b,c){-1===Object.keys(a).indexOf(b)&&thrower("OhnK","Object has no key",c+b)},hasNoKey:function(a,b,c){-1!==Object.keys(a).indexOf(b)&&thrower("OhK","Object has key",c+b)},fnFalse:function(a){a()&&thrower("FarT","function already returns true",fnName(a))},byCallbackObject:function(a,b,c){var d;for(d in b)void 0!==c?b[d](a[c[d]],c[d]):b[d](a[d],d)}},injector(function(){window.Quadtree2=Quadtree2},function(){module.exports=Quadtree2});